# 开发记录小技巧

#### 1.判断元素是否重复

先遍历数组或字符串,判断indexOf()和lastIndexOf()是否相等

```js
 var arr = [1, 2, 3, 1, 3, 5, 2, 4, 6]
        var str = "hello world evening"
        var newArr = []
        var newStr = ""

        for (let index = 0; index < arr.length; index++) {
            let item = arr[index]
            newArr.push(arr.indexOf(item) == arr.lastIndexOf(item) ?  arr[index]: "")
        }
        console.log(newArr);
        for (let index = 0; index < str.length; index++) {
            let item = str.charAt(index)
            newStr += str.indexOf(item) == str.lastIndexOf(item) ?  str.charAt(index):""

        }
        console.log(newStr);
```

留下只出现一次的元素

#### 2.chrome调试工具

修改元素属性值

shift +↑可以加10

点击 + 可以添加一个类

点击 ... 可以给元素添加 字体色,背景色方便测试

右建点元素可以选择添加伪类

对着元素点击H键可以将元素设为占位不可见

右键元素点击store as global var 可获取元素的临时变量

断点调试,在Source栏里选择对应的js文件,在对应函数处加断点,使用step进行测试

#### 3.开发规范

基本类型数据直接赋值

引用类型传递引用地址

幂运算 2**10

#### 4.float导致的不占位

可以在浮动元素下面加clear:both保持正常的占位

#### 5.外边距合并问题

两个相邻的盒子使用外边距时会出现外边距合并,即边距只取两者最大值

可以创建一个无边距的父级div

```html
<style>	
    .blue, .red-inner {
			  height: 50px;
			  margin: 10px 0;
			}
			
			.blue {
			  background: blue;
			}
			
			.red-outer {
			  overflow: hidden;
			  background: red;
			}
</style>
<div class="blue"></div>
			<div class="red-outer">
			  <div class="red-inner">red inner</div>
			</div>

```

#### 6.点击元素外的地方关闭该元素(单个元素好用)

点击任意地方都关闭该元素

```js
$(document).click(function(){
$("#target").hide();
});
```

target也属于document，点击target也会让自己隐藏，显然这不是想要的，这时候要阻止冒泡事件，即document的事件对target无效

```js
$("#target").click(function(e){
e.stopPropagation();
});
```

#### 7.绝对定位后,父级元素定义

元素在绝对定位后,寻找父级元素不再遵循原本的HTML结构即最近的上一级, 而是已经进行定位的最近元素,如果此时使用width:100%,也说按照定位的最近元素来继承

```css
	.grandfather {
			width: 300px;
			height: 18.75rem;
			background: pink;
			position: relative;
		}

		.father {
			width: 200px;
			height: 6.25rem;
			background: #00BFFF;
		}

		.son {
			width: 100%;
			/* width: 50px; */
			height: 3.125rem;
			background: red;
			position: absolute;
		}
```
<div class="grandfather">
			爷爷
			<div class="father">
				爸爸
				<div class="son">
					儿子
				</div>
			</div>
		</div>

此时爷爷div相对定位,儿子绝对定位,导致儿子的父级元素变成爷爷div此时的width:100% 变成300px

#### 8.不定高的元素过渡效果

```css
<style type="text/css">
			.outer {
				width: 1000px;
				margin: 0 auto;
			}
			.outer>li {
				float: left;
			}
			.outer>li:hover .inner {
				max-height: 300px;
			}
			.inner {
				overflow: hidden;
				max-height: 0;
				transition: all .5s;
			}
		</style>
```

```html
	<nav>
			<ul class="outer">
				<li>标题一
					<ul class="inner">
						<li>二级菜单1</li>
						<li>二级菜单2</li>
						<li>二级菜单3</li>
					</ul>
				</li>
				<li>标题一
					<ul class="inner">
						<li>二级菜单1</li>
						<li>二级菜单2</li>
						<li>二级菜单3</li>
					</ul>
				</li>
			</ul>
		</nav>
```

#### 9.锚点链接

用id索引

```html
 <a href="#link">点我跳转</a>
 <div id="link">跳转到这里</div>
```

#### 10.写静态网页总体思路（不断更新）

- 目前，网页主体是1200px宽，设置固定宽,加margin:0 auto 保障内容不折行
- 遇到导航栏，可以把li 设置float：left ，下面的部分可以使用clear：both ，让上面的部分占（不影响布局）
- 关于页面头部,尾部抽取,可以将公共的html代码复制加到js "document.writeln(  加到这 )",再用script标签引入到页面(目前只是静态,无法嵌入变量)

#### 11.导航栏文字间的细线

边框(适用于细线大于等于文字的高度)

```css
li:not(:first-child){
			border-left: 1px solid #000000;
		}
```
伪元素（）

```css
		li:not(:first-child)::before{
				content: "";
				width: 1px;
				height: auto;
				position: absolute;
				right: 0;
			}
```

span

```css
span {margin: 10px 6px 0px 6px;
    height: 16px;
    width: 0px;
    overflow: hidden;
    vertical-align: middle;
    border-right: 1px #e5e5e5 solid;}
```

直接键入“|”左右的元素用padding保持距离，也可以实现效果，颜色会继承父级的color属性

#### 12.函数filter,map,reduce

过滤函数

`filter()`不会对空数组进行检测,不改变原始数组

```js
array.filter(function(currentValue,index,arr), thisValue)
let arr =[1,2,3,4,5,6]
arr.filter((cur,index,arr)=>{
return cur>3   //此处为false时删除该元素,会改变数组长度
})
// [4,5,6]
```

求和函数

` reduce() `  对于空数组是不会执行回调函数的。

```js
array.reduce(function(total,currentValue,index,arr), begin)
let arr =[1,2,3,4,5,6]
arr.reduce((total,cur,index,arr)=>{
return total+cur
},0) //这个初始值可以是"[]","{}"可以将数组变成对象
//21
```

映射函数

`map()`不会对空数组进行检测,不改变原始数组

```js
array.map(function(currentValue, index, arr), thisValue)
let array = [1, 2, 3, 4, 5];

let newArray = array.map((item) => {
    return item * item;
})
//[1,4,9,16,25]
```

filter和map组合遍历筛选年龄大于18的姓名

```js
let objarr = [{
				name: "joy",
				age: 20,
				sex: "male"
			},
			{
				name: "lily",
				age: 18,
				sex: "female"
			},
			{
				name: "john",
				age: 21,
				sex: "male"
			},
			{
				name: "jane",
				age: 15,
				sex: "female"
			},
		]   console.log(objarr.filter((cur,i,arr)=>cur.age>18).map((cur,i,arr)=>cur.name));		
```
ps:一行代码数组去重

```js
arr = [1, 2, 1, 3, 0, 0, 0, 1]
console.log([... new Set(arr)]);  
```

ps:返回只出现一次的元素

```js
arr.filter((cur, i, arr) => {
				return arr.indexOf(cur) === arr.lastIndexOf(cur)
			})
```

#### 13.路由跳转(传参)

###### 1. router-link

1. 1不带参数

```
<router-link :to="{name:'home'}">
<router-link :to="{path:'/home'}"> //name,path都行, 建议用name
```


// 注意：router-link中链接如果是'/'开始就是从根路由开始，如果开始不带'/'，则从当前路由开始。

1.2.带参数

```
<router-link :to="{name:'home', params: {id:1}}">
```

// params传参数 (类似post)
// 路由配置 path: "/home/:id" 或者 path: "/home:id"
// 不配置path ,第一次可请求,刷新页面id会消失,配置path,刷新页面id会保留

// html 取参 $route.params.id, script 取参 this.$route.params.id

```
<router-link :to="{name:'home', query: {id:1}}">
```

1.3query传参数 (类似get,url后面会显示参数)
// 路由可不配置

// html 取参 $route.query.id, script 取参 this.$route.query.id

###### 2. this.$router.push() (函数里面调用)

2.1不带参数

this.$router.push('/home')
this.$router.push({name:'home'})
this.$router.push({path:'/home'})

2.2query传参

this.$router.push({name:'home',query: {id:'1'}})
this.$router.push({path:'/home',query: {id:'1'}})

// html 取参 $route.query.id, script 取参 this.$route.query.id

2.3params传参

this.$router.push({name:'home',params: {id:'1'}}) // 只能用 name

// 路由配置 path: "/home/:id" 或者 path: "/home:id" ,
// 不配置path ,第一次可请求,刷新页面id会消失
// 配置path,刷新页面id会保留

// html 取参 $route.params.id,script 取参 this.$route.params.id

2.4query和params区别
query类似 get, 跳转之后页面 url后面会拼接参数,类似?id=1, 非重要性的可以这样传, 密码之类还是用params刷新页面id还在

params类似 post, 跳转之后页面 url后面不会拼接参数 , 但是刷新页面id 会消失

###### 3. this.$router.replace() (用法同上,push)

###### 4. this.$router.go(n) ()

this.$router.go(n)
向前或者向后跳转n个页面，n可为正整数或负整数

###### ps : 区别

this.$router.push
跳转到指定url路径，并想history栈中添加一个记录，点击后退会返回到上一个页面
this.$router.replace
跳转到指定url路径，但是history栈中不会有记录，点击返回会跳转到上上个页面 (就是直接替换了当前页面)

this.$router.go(n)
向前或者向后跳转n个页面，n可为正整数或负整数

#### 14.qs处理url参数

`qs.parse` 方法可以把一段格式化的字符串转换为对象格式，比如

```js
let url = 'http://item.taobao.com/item.htm?a=1&b=2&c=&d=xxx&e';
let data = qs.parse(url.split('?')[1]);

// data的结果是
{
    a: 1, 
    b: 2, 
    c: '', 
    d: xxx, 
    e: ''
}

```

`qs.stringify` 则和 `qs.parse` 相反，是把一个参数对象格式化为一个字符串。

```js
let params = { c: 'b', a: 'd' };
qs.stringify(params)

// 结果是
'c=b&a=d'
```

#### 15.vue ref和$ref

1.获取本页面的dom元素(类似js获取元素,一般用来获取数据,调用函数)

```xml
<template>
  <div id="app">
    <div ref="testDom">11111</div>
    <button @click="getTest">获取test节点</button>
  </div>
</template>
<script>
export default {
  methods: {
    getTest() {
      console.log(this.$refs.testDom)
    }
  }
};
</script>
```

2.父组件获取子组件的数据和方法

```xml
<template>
  <div id="app">
    <son ref="son"/>
    <button @click="getHello">获取helloworld组件中的值</button>
  </div>
</template>
<script>
import son from "./components/son.vue";
export default {
  components: {
    son
  },
  methods: {
    getHello() {
      console.log(this.$refs.son.msg) //获取son data 里msg的数据
        this.$refs.son.fun(); //调用son method 里fun方法
    }
  }
};
</script>
```

3.父子组件传递调用,(用于更新数据)

  子组件

```vue
<template>
  <div>
</div>
</template>
<script>
export default {
  methods: {
    open() {
      console.log("调用了");
      //  父组件调用了这个方法,用emit传递给父级,调用父级的refreshData
      this.$emit("refreshData");
    }
  }
}
</script>
```

父组件

```vue
<template>
  <div id="app">
    <son ref="hello" @refreshData="getData"/>
    <button @click="getHello">获取helloworld组件中的值</button>
  </div>
</template>
<script>
import son from "./components/son.vue";
export default {
  components: {
    son
  },
  methods: {
    getHello() {
    //此处调用子组件的方法
      this.$refs.son.open()
    },
    getData() {
      console.log('111111')
    }
  }
};
</script>
```

#### 16.JSON.parse()和JSON.Stringfy()

将json转为对象,属性值必须要用"" 包起来

JSON.parse()  把字符串转换成对象　

```js
// 数组
let a = '["a","b","c"]';// √
let b = "['a','b','c']";// X

// 对象
let a1 = '{"name":"听风是风","age":"26"}';// √
let b1 = "{'name':'听风是风','age':'26'}";// X

console.log(JSON.parse(a))// Array  ["a", "b", "c"]
console.log(JSON.parse(a1))// Object {name: "听风是风", age: "26"}
```

JSON.Stringfy() 把对象转化为字符串

```js
let a=["a", "b", "c"]
let a1= {name: "听风是风", age: "26"}
console.log(JSON.Stringfy(a))// Array  '["a", "b", "c"]'
console.log(JSON.Stringfy(a1))// Object '{name: "听风是风", age: "26"}'
```

#### 17.BFC

定义:浮动元素和绝对定位元素,非块级容器的块级容器(inline-block),以及overflow不为"visible"的盒子

(满足一个或多个)触发条件:

- 根元素()

- 浮动元素（元素的 float 不是 none）

- 绝对定位元素（元素的 position 为 absolute 或 fixed）

- 行内块元素（元素的 display 为 inline-block）

- 表格单元格（元素的 display为 table-cell，HTML表格单元格默认为该值）

- 表格标题（元素的 display 为 table-caption，HTML表格标题默认为该值）

- 匿名表格单元格元素（元素的 display为 table、table-row、 table-row-group、table-header-group、table-footer-group（分别是HTML table、row、tbody、thead、tfoot的默认属性）或 inline-table）

- overflow 值不为 visible 的块元素 -弹性元素（display为 flex 或 inline-flex元素的直接子元素）

- 网格元素（display为 grid 或 inline-grid 元素的直接子元素） 等等。

  bfc渲染规则

  BFC垂直方向边距重叠(外边距合并)

  BFC的区域不会与浮动元素的box重叠

  BFC是一个独立的容器，外面的元素不会影响里面的元素

  计算BFC高度的时候浮动元素也会参与计算

简单触发BFC ,设置overflow:hidden

可以规避父级高度塌陷,外边距合并,内边距塌陷

#### 18.数组扁平化flat

```js
[1, 2, [3, [4, 5]]].flat()
// [1, 2, 3, [4, 5]]
[1, 2, [3, [4, 5]]].flat(2)
// [1, 2, 3, 4, 5]
//flat(infinity) 把多维数组变成一维数组,空格元素会被删除(不改变原数组)
//flatMap()只能展开一层数组
//相当于flat()和map()结合
```

#### 19.js深浅拷贝

浅拷贝

```js
let arr=[2,3,123,123]
let newarr =arr.slice() //此时arr==newarr返回 false,newarr使用的是新的内存地址
```

浅拷贝只能拷贝一层对象,如果存在对象嵌套,则无法完成拷贝

```js
let arr = [1, 2, {val: 4}];
let newArr = arr.slice();
newArr[2].val = 1000;
console.log(arr);//[ 1, 2, { val: 1000 } ]
```

此时改变原数组

深拷贝

```js
JSON.parse(JSON.stringify(arr));
```